// Load history
                var chatHistory = new Microsoft.SemanticKernel.ChatCompletion.ChatHistory();
                var userHistory = await _chatService.GetMessagesAsync(userQueryDTO.SessionId, 10);
                foreach (var msg in userHistory)
                {
                    if (msg.Sender == "User") chatHistory.AddUserMessage(msg.Message!);
                    else chatHistory.AddAssistantMessage(msg.Message!);
                }
                chatHistory.AddUserMessage(userQueryDTO.Query);

                // Prepare plugin instances
                var ragPlugin = new RAGPlugin(_kernel, _embeddingService, _blobService);
                var weatherPlugin = new WeatherPlugin(_kernel, _configuration);
                var emailPlugin = new EmailWriterPlugin(_httpClient, _configuration);
                var documentPlugin = new DocumentGenerationPlugin(_blobService, _documentsProcessFactory);

                // Create agents
                const string RAGAgentName = "RAGAgent";
                const string WeatherAgentName = "WeatherAgent";
                const string EmailAgentName = "EmailAgent";
                const string DocumentAgentName = "DocumentAgent";
                const string CoordinatorAgentName = "CoordinatorAgent";
                const string RefinerAgentName = "RefinerAgent";

                var writerAgent = new ChatCompletionAgent
                {
                    Name = RAGAgentName,
                    Instructions = "Use RAGPlugin to fetch and return relevant documents only. If no relevant information is found, reply 'No relevant information found'. Do not speculate.",
                    Kernel = _kernel.Clone()
                };
                writerAgent.Kernel.ImportPluginFromObject(ragPlugin, nameof(ragPlugin));

                var weatherAgent = new ChatCompletionAgent
                {
                    Name = WeatherAgentName,
                    Instructions = "Only respond if the user queries weather-related information. Provide the current weather based on the user's location.",
                    Kernel = _kernel.Clone()
                };
                weatherAgent.Kernel.ImportPluginFromObject(weatherPlugin, nameof(weatherPlugin));

                var emailAgent = new ChatCompletionAgent
                {
                    Name = EmailAgentName,
                    Instructions = "Generate an email based on the conversation context, including any relevant data or attachments.",
                    Kernel = _kernel.Clone()
                };
                emailAgent.Kernel.ImportPluginFromObject(emailPlugin, nameof(emailPlugin));

                var documentAgent = new ChatCompletionAgent
                {
                    Name = DocumentAgentName,
                    Instructions = "Generate a document (PDF/Word) based on the user request, including all relevant data.",
                    Kernel = _kernel.Clone()
                };
                documentAgent.Kernel.ImportPluginFromObject(documentPlugin, nameof(documentPlugin));

                var coordinatorAgent = new ChatCompletionAgent
                {
                    Name = CoordinatorAgentName,
                    Instructions = "Coordinate the flow of the conversation between the agents. Ensure only one agent speaks at a time and decide which agent should respond.",
                    Kernel = _kernel.Clone()
                };

                var refinerAgent = new ChatCompletionAgent
                {
                    Name = RefinerAgentName,
                    Instructions = "Refine the final answer provided by other agents and present the best response.",
                    Kernel = _kernel.Clone()
                };

                // Define the termination function (decides when to stop)
                #pragma warning disable SKEXP0110 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.
                KernelFunction terminationFunction =
                    AgentGroupChat.CreatePromptFunctionForStrategy(
                        $$$"""
                        Determine if a final answer has been provided. If so, respond with 'End' to indicate that the process should stop.

                        History:
                        {{$chatHistory}}
                        """,
                        safeParameterNames: "$chatHistory");
                #pragma warning restore SKEXP0110 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.

                // Define the termination strategy
                #pragma warning disable SKEXP0110 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.
                KernelFunctionTerminationStrategy terminationStrategy =
                    new(terminationFunction, _kernel)
                    {
                        // The refiner agent will decide when the conversation should end.
                        Agents = [refinerAgent],
                        // Parse the response to check if the final answer is ready
                        ResultParser = (result) => result.GetValue<string>()?.Contains("yes", StringComparison.OrdinalIgnoreCase) ?? false,
                        // The prompt variable name for the history argument
                        HistoryVariableName = "chatHistory",
                        // Limit history to the last 1 message for efficiency
                        HistoryReducer = new ChatHistoryTruncationReducer(1),
                        // Limit total number of iterations to avoid endless loops
                        MaximumIterations = 10
                    };
                #pragma warning restore SKEXP0110 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.

                // Define the conversation flow
                var selectionPrompt = $$$"""
                Determine which agent should respond based on the context of the conversation.

                Available agents:
                - {{{RAGAgentName}}}: Fetches relevant knowledge from retrieved documents.
                - {{{WeatherAgentName}}}: Responds if the query involves weather-related information.
                - {{{EmailAgentName}}}: Responds if an email has to be written.
                - {{{DocumentAgentName}}}: Responds if a document needs to be generated.
                - {{{CoordinatorAgentName}}}: Coordinates the flow between agents.
                - {{{RefinerAgentName}}}: Refines and provides the final answer.

                Rules:
                - If the query requires knowledge-based information (facts, templates, how-tos, explanations), use {{{RAGAgentName}}}.
                - If the query is about weather (forecast, temperature, rain, etc.), use {{{WeatherAgentName}}}.
                - If the query is to compose, draft, or format an email, use {{{EmailAgentName}}}.
                - If the query is to create, get templates, or format a document (e.g., report, template, plan), use {{{DocumentAgentName}}}.
                - If it is unclear, ambiguous, or none of the above categories fit, use {{{CoordinatorAgentName}}} by default.
                - After any agent responds, the next agent in line will take the turn based on the updated context.

                **Important: Always choose an agent. Never leave the selection empty. Default to {{{CoordinatorAgentName}}} if unsure.**

                Conversation History:
                {{$chatHistory}}
                """;

                #pragma warning disable SKEXP0110 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.
                var selectionFunction = AgentGroupChat.CreatePromptFunctionForStrategy(
                    selectionPrompt, safeParameterNames: "chatHistory"
                );
                #pragma warning restore SKEXP0110 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.

                #pragma warning disable SKEXP0110 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.
                var selectionStrategy = new KernelFunctionSelectionStrategy(selectionFunction, _kernel)
                {
                    InitialAgent = coordinatorAgent,
                    ResultParser = result => result.GetValue<string>() ?? CoordinatorAgentName,
                    HistoryVariableName = "chatHistory",
                    HistoryReducer = new ChatHistoryTruncationReducer(5)
                };
                #pragma warning restore SKEXP0110 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.

                // Configure group chat
                #pragma warning disable SKEXP0110 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.
                var groupChat = new AgentGroupChat(writerAgent, weatherAgent, emailAgent, documentAgent, coordinatorAgent, refinerAgent)
                {
                    ExecutionSettings = new()
                    {
                        SelectionStrategy = selectionStrategy,
                        TerminationStrategy = terminationStrategy
                    }
                };
                #pragma warning restore SKEXP0110 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.

                groupChat.AddChatMessage(new ChatMessageContent(role: AuthorRole.User, content: userQueryDTO.Query));

                List<ChatMessageContent> response = new List<ChatMessageContent>();
                bool terminationReached = false;
                string finalAnswer = string.Empty;

                // Run the conversation
                await foreach (ChatMessageContent content in groupChat.InvokeAsync())
                {
                    response.Add(content);
                }

                // Finalize the answer for user
                finalAnswer = terminationReached ? finalAnswer : "No final answer available. Please try again.";

                // Prepare the response DTO for the user
                //var result = new ChatResponseDTO
                //{
                //    FinalAnswer = finalAnswer, // Final answer to return to the user
                //    AgentCommunication = response // History of agent communications
                //};

                // Persist chat history (optional)
                await _chatService.AddMessagesAsync(new List<ChatHistory>
                {
                    new ChatHistory { SessionId = userQueryDTO.SessionId, Message = userQueryDTO.Query, Sender = "User", Timestamp = DateTime.UtcNow },
                    new ChatHistory { SessionId = userQueryDTO.SessionId, Message = finalAnswer, Sender = "Assistant", Timestamp = DateTime.UtcNow }
                });

                return Ok(finalAnswer); // Send the final response to the user